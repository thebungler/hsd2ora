import xml.etree.ElementTree

#for some reason, this tries to write boolean values to the xml. so i've modified it to convert them to strings first.
def override_escape_attrib(text):
    # escape attribute value
    try:
        if (isinstance(text, bool)):
            text = str(text).lower()
        if "&" in text:
            text = text.replace("&", "&amp;")
        if "<" in text:
            text = text.replace("<", "&lt;")
        if ">" in text:
            text = text.replace(">", "&gt;")
        if "\"" in text:
            text = text.replace("\"", "&quot;")
        # Although section 2.11 of the XML specification states that CR or
        # CR LN should be replaced with just LN, it applies only to EOLNs
        # which take part of organizing file into lines. Within attributes,
        # we are replacing these with entity numbers, so they do not count.
        # http://www.w3.org/TR/REC-xml/#sec-line-ends
        # The current solution, contained in following six lines, was
        # discussed in issue 17582 and 39011.
        if "\r" in text:
            text = text.replace("\r", "&#13;")
        if "\n" in text:
            text = text.replace("\n", "&#10;")
        if "\t" in text:
            text = text.replace("\t", "&#09;")
        return text
    except (TypeError, AttributeError):
        _raise_serialization_error(text)

xml.etree.ElementTree._escape_attrib = override_escape_attrib


#note: the czipfile lib in pip only works for python2. this script makes use of the python3 port by ziyuang on github
#https://github.com/ziyuang/czipfile
from czipfile import ZipFile
from PIL import Image
import os
import tempfile
import json
import pyora
import io
import shutil

import argparse
import sys
from pathlib import Path
from batch_processing import Batch


#makes pyora use czipfile to save, so it goes faster 
def overridesave(self, path_or_file, composite_image=None, use_original=False):
    """Save the current project state to an ORA file.

    Args:
        path (str): path to the ora file to save
        composite_image (PIL.Image()): PIL Image() object of the composite rendered canvas. It is used to
            create the mergedimage full rendered preview, as well as the thumbnail image. If not provided,
            one will be generated by pyora's Render() class by stacking all of the layers in the project.
            Note that the image you pass may be modified during this process, so if you need to use it elsewhere
            in your code, you should copy() first.
        use_original (bool): If true, and If there was a stored 'mergedimage' already in the file which was opened,
            use that for the 'mergedimage' in the new file, instead of rendering a new one.
    """
    import czipfile
    with czipfile.ZipFile(path_or_file, "w") as zipref:

        zipref.writestr("mimetype", "image/openraster".encode())

       
        if not composite_image:
            if use_original and self._extracted_merged_image:
                composite_image = self._extracted_merged_image
            else:
                # render using our built in library
                r = pyora.Render.Renderer(self)
                composite_image = r.render()
        self._zip_store_image(zipref, "mergedimage.png", composite_image)

        pyora.Render.make_thumbnail(composite_image)  # works in place
        self._zip_store_image(zipref, "Thumbnails/thumbnail.png", composite_image)
        
        
        filename_counter = 0
        for layer in self.children_recursive:
            if layer.type == pyora.TYPE_LAYER:
                new_filename = f"/data/layer{filename_counter}.png"
                layer._elem.attrib["src"] = new_filename
                filename_counter += 1
                self._zip_store_image(
                    zipref, layer["src"], layer.get_image_data(raw=True)
                )
        
        zipref.writestr("stack.xml", xml.etree.ElementTree.tostring(self._elem_root, method="xml"))

pyora.Project.save = overridesave

#all blending modes i was able to select in hipaint are listed. gaps present are as hipaint has provided them.
blendmodes = {  0 : "svg:src-over", 
                1 : "svg:overlay",
                2 : "svg:darken",
                3 : "svg:multiply",
                4 : "svg:color-burn",
                5 : "krita:linear_burn", #krita specific
                6 : "krita:darker color", #krita specific
                7 : "svg:lighten",
                8 : "svg:screen",
                9 : "svg:color-dodge",
                10 : "svg:plus",
                11 : "krita:lighter color", #krita specific
                12 : "svg:soft-light",
                13 : "",
                14 : "svg:hard-light",
                15 : "krita:vivid_light", #krita specific
                16 : "krita:linear light", #krita specific
                17 : "krita:pin_light", #krita specific
                18 : "krita:hard mix", #krita specific
                19 : "svg:difference",
                20 : "krita:exclusion", #krita specific
                21 : "",
                22 : "krita:divide", #krita specific
                23 : "",
                24 : "",
                25 : "svg:hue",
                26 : "svg:saturation",
                27 : "svg:color",
                28 : "svg:luminosity",
                29 : "krita:subtract", #krita specific
                30 : "krita:dissolve", #krita specific
                31 : "",
                32 : "",
                #33 : "group penetrate" #this one is handled differently, as it is not a layer mode in ora, but a distinct attribute
}

def int_to_hex_color(value):
    # Convert signed int to unsigned int
    unsigned_value = value & 0xFFFFFFFF
    
    # Extract the color components
    alpha = (unsigned_value >> 24) & 0xFF
    red = (unsigned_value >> 16) & 0xFF
    green = (unsigned_value >> 8) & 0xFF
    blue = unsigned_value & 0xFF
    
    # Format the hex color code without the alpha
    hex_color = f'#{red:02X}{green:02X}{blue:02X}'
    return hex_color


#takes an hsd file, converts to ora through a bunch of other functions, saves to output 
def convertToORA(filename, output):
    print("Attempting to convert " + str( os.path.abspath(filename)))
    #generate the temp dir we'll be using throughout the function, extract hsd into it + load project json
    tempdir = tempfile.TemporaryDirectory()
    projectDetails = extractProject(filename, tempdir)
    projpath = os.path.join(tempdir.name, "temp")
    
    #create new ora with height taken from hsd json 
    oraProject = pyora.Project.new(projectDetails['bounds']['canvas-width'], projectDetails['bounds']['canvas-height'])
    #TO-DO: cropping?
    
    #background is handled separately from layers in the hsd, so we do it before
    #converting the colour to hex might be unnecessary. test
    bgColor = Image.new('RGB', (projectDetails['bounds']['canvas-width'], projectDetails['bounds']['canvas-height']), int_to_hex_color(projectDetails['background']['bg-color']))
    oraProject.add_layer(bgColor, '/background')
    
    #loop through layers and add them to the project
    for x in projectDetails['layers']:
        generateLayer(x, projectDetails, oraProject, projpath)
    #pyora is supposed to be able to handle groups automatically by setting the paths correctly, but i couldn't get it to work, so we loop through the layers again and assign children to parents (because i fear what will happen if i try to assign a layer as a child of a layer that doesn't exist yet)
    for x in projectDetails['layers']:
        assignParent(x['filename-id'], x['parent-id'], oraProject)
    #TO-DO: take "selected-layer" value from json and set selected layer in the ora  (selected-layer will be set to the uuid of the relevant ora layer). bg layer may require special accommodations, i haven't tested it.
    #that should be everything finished. export as osd file. right now to current directory but we can implement user input on that later
    oraProject.save(output)
    print("Saved file to " + str( os.path.abspath(output)))
    '''
    #refraining from rendering a composite image speeds up performance a bit. may add a parameter to let the user do this if they so wish later
    oraProject.save(output,composite_image=(Image.new("RGB", (1, 1))))
    '''

#assigns a layer in an ora file as a child to another layer using UUIDs
def assignParent(childUUID, parentUUID, oraProject):
    #if we're given an id of 0 or less, the parent layer does not exist, as ensured by extractProject. so we leave it be, as it ought to be in root dir already
    if(parentUUID <= 0):
        return True

    #convert to string b/c they're probably ints from the hsd file
    oraProject.move(str(childUUID), str(parentUUID), dst_z_index='above')
    return True

#takes a layer dict from an hsd json file (converted to a dict beforehand), turns into an ora layer in provided ora project file. also needs to be provided with the hsd json as a dict
def generateLayer(layer, hsdDict, oraProject, projpath): 
        #as far as i can tell, bean-type determines whether it's a paint layer or group
        if layer['bean-type'] == 1:
            new_layer = oraProject.add_group(path="/")
        else:
            #if it's an image layer, get the path of where image data should be
            layerImageFilePath = os.path.join(projpath, ("flayer_"+str(layer['filename-id'])))
            #layer may be empty. check if file id exists. if it does, add it as the image data
            if(os.path.isfile(layerImageFilePath)):
                layerImageDataArray = readLayer(layerImageFilePath) #returns image data, x offset, y offset 
                #all of my projects were being exported upside down and mirrored, so i added this. i suppose that's just how the bitmap loads?
                invertedXOffset = hsdDict['bounds']['canvas-width'] - layerImageDataArray[1] - layerImageDataArray[0].width
                invertedYOffset = hsdDict['bounds']['canvas-height'] - layerImageDataArray[2] - layerImageDataArray[0].height
                imageData = layerImageDataArray[0].rotate(180) 
                #imageData = imageData.transpose(method=Image.FLIP_LEFT_RIGHT)
                new_layer  = oraProject.add_layer(imageData, "/", offsets=(invertedXOffset, invertedYOffset))
                
            #or else, if the layer is empty, generate empty image data (so that it doesn't lock up for lack of data to render)
            else:
                new_layer  = oraProject.add_layer(Image.new("RGB", (1, 1)), "/", offsets=(0, 0))
        #filename-id is the important id. the regular id value, as far as i can tell, just indicates the order of the layers--which we automatically derive from the order of the entries in the json file, which just so happens to be the same order as the id values
        new_layer.uuid = str(layer['filename-id'])
        new_layer.name = str(layer['name'])
        #now add any attributes
        if layer['visible'] is False:           
            new_layer.visible = False
        new_layer.opacity = layer['opacity']
        #"lock-opacity" in the hsd is whether transparent pixels are locked. i cannot find an attribute in the osd specs that implements this, and since krita does not retain this setting upon saving, i do not think there is one. however, i've put it here anyway, in case it's implemented later. thankfully, it does not affect the final image.
        new_layer["lock-opacity"] = layer['lock-opacity']
        if layer['blend'] == 33:
            #penetrate blend mode is treated as an attribute in ORA
            new_layer.isolated = False;
        else:
            #blend determines blend mode. this is a pain, because they're assigned numbers instead of string based names. i've made a dict with all the numbers assigned their appropriate blending mode name, for ease of use.
            #if you crash because of an unspecified blend mode, add it to the dict above, and then let me know about it so i can do the same
            new_layer["composite-op"] = blendmodes[layer['blend']]
        new_layer["alpha-preserve"] = layer['clip']
        new_layer["edit-locked"] = layer['lock-layer']
        #"is-foreground" ?
        #"is-background" ?
        return True

#reads an hsd layer file and returns a list containing an image, plus offsets
def readLayer(filename):
    #the layer file is a zip containing a bitmap. first, we need to extract the zip.
    tempdir = tempfile.TemporaryDirectory()
    with ZipFile(filename) as zf:
        zf.extractall(path=tempdir.name)
    #the file inside will be called 'zip'
    with open((os.path.join(tempdir.name, "zip")), mode="rb") as f:
        buffer_size = 2**10*8
        #we open an 8kb chunk of our file
        chunk = f.read(buffer_size)
        #read header data
        width = int.from_bytes(chunk[8:10], "little")
        height = int.from_bytes(chunk[10:12], "little")
        x_offset = int.from_bytes(chunk[4:6], "little")
        y_offset =int.from_bytes(chunk[6:8], "little")
        #read the rest of the non-header bytes in the chunk. store in bytearray
        imageData = bytearray(chunk[12:(buffer_size + 12)])
        #loop through rest of bytes in file and append to imageData
        while chunk:
            chunk = f.read(buffer_size)
            imageData.extend(chunk)
        #we need 00 00 00 00 to pad out the end of the image until (the amount of bytes from end of headers onward)/4 is equivalent to width*height
        
        #size of pure image data without headers
        actualSize = int((os.path.getsize(filename)-13)/4)

        sizeToMeet = width*height
        extraBytesNeeded = sizeToMeet - actualSize
        for _ in range(int(extraBytesNeeded)):
            imageData.extend((b'\x00\x00\x00\x00')) 
        im = Image.new("RGBA", (width, (height)))
        im.frombytes(imageData)
        return([im, x_offset, y_offset])

#extracts an hsd project from a provided path, extracts to provided directory, fixes parent ids in project json
#returns the fixed project json as a dict
def extractProject(filename, directory):
    with ZipFile(filename, 'r') as zf:
        zf.extractall(path=directory.name,pwd=b'huion2018')
        #all files will be in a subdir "temp" due to the way hipaint structures project files
    with open(os.path.join(directory.name, "temp", "project.json")) as f:
        projectDetails = json.load(f)
    #hsd files have weird ways of designating that a layer does not have a parent. to get around that, we get a list of every id that actually exists, and run through the list of layers, checking parent IDs against it. if the parent id does not actually exist, we set it to a negative value, so we can later easily check if a layer is on the root layer by seeing if parent-id <= 0
    extantIDs = []
    for x in projectDetails['layers']:
        extantIDs.append(x['filename-id'])
    for x in projectDetails['layers']:
        if x['parent-id'] not in extantIDs:
            x['parent-id'] = -999
    return projectDetails

#batch processing stuff that i threw in and didn't test thoroughly, sorry if there's issues
def parse_command_line(batch: Batch):
    parser = argparse.ArgumentParser(description='Batch input',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Setup custom script arguments here

    return batch.parse_args(parser)


def parallel_process(input: Path, output: Path, args: argparse.Namespace):

    # Load an input file, apply some processing, and save to output file here
    convertToORA(input, output)
    return   


def main(argv):
    
    # Instantiate batch
    batch = Batch(argv)
    batch.set_io_description(input_help='input files', output_help='output directory')
    
    # Parse arguments
    args = parse_command_line(batch)
    
    # Start processing and retrieve the results at the end if any
    data = batch.run(parallel_process, output_ext=".ora")
    
    # clean up residue
    dirpath = Path(os.path.join(args.output, "_batch"))
    if dirpath.exists() and dirpath.is_dir():
        shutil.rmtree(dirpath)


if __name__ == "__main__":
    main(sys.argv[1:])


